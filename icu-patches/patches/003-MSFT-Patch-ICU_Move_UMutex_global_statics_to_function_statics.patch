From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniel Ju <41210545+daniel-ju@users.noreply.github.com>
Date: Fri, 10 Apr 2020 17:19:52 +0000
Subject: [PATCH] Merged PR 11341: ICU: Move global statics to function statics
 for UMutex

This is needed until we can update to VS2019.

Global static variables don't have a defined init/deinit order in C++ (see "Static Initialization Order Fiasco"). Instead, static variables should be initialized inside of a function.

This change is mostly hand cherry-picked from Andy's upstream change in [PR #522](https://github.com/unicode-org/icu/pull/522).

There is an additional change to the `i18n/timezone.cpp` file, which was changed in [PR #649](https://github.com/unicode-org/icu/pull/649) but reverted back to a static global variable in [PR #655](https://github.com/unicode-org/icu/pull/655).

---
 .../source/common/characterproperties.cpp     |  9 ++--
 icu/icu/icu4c/source/common/locid.cpp         |  9 ++--
 icu/icu/icu4c/source/common/serv.cpp          | 21 +++++----
 icu/icu/icu4c/source/common/servnotf.cpp      | 13 +++---
 icu/icu/icu4c/source/common/ucnv_bld.cpp      | 27 ++++++------
 icu/icu/icu4c/source/common/ucurr.cpp         | 34 +++++++++------
 icu/icu/icu4c/source/common/umutex.cpp        |  9 ++--
 icu/icu/icu4c/source/common/uresbund.cpp      | 17 +++++---
 icu/icu/icu4c/source/common/usprep.cpp        | 27 ++++++------
 icu/icu/icu4c/source/i18n/astro.cpp           | 17 +++++---
 icu/icu/icu4c/source/i18n/chnsecal.cpp        | 17 +++++---
 icu/icu/icu4c/source/i18n/dtitvfmt.cpp        | 19 ++++----
 icu/icu/icu4c/source/i18n/smpdtfmt.cpp        | 17 +++++---
 icu/icu/icu4c/source/i18n/timezone.cpp        | 11 +++--
 icu/icu/icu4c/source/i18n/translit.cpp        | 43 ++++++++++---------
 icu/icu/icu4c/source/i18n/tridpars.cpp        | 11 +++--
 icu/icu/icu4c/source/i18n/tzfmt.cpp           | 13 +++---
 icu/icu/icu4c/source/i18n/tzgnames.cpp        | 40 +++++++++--------
 icu/icu/icu4c/source/i18n/tznames.cpp         | 15 ++++---
 icu/icu/icu4c/source/i18n/tznames_impl.cpp    | 19 ++++----
 icu/icu/icu4c/source/i18n/zonemeta.cpp        | 29 +++++++------
 21 files changed, 243 insertions(+), 174 deletions(-)

diff --git a/icu/icu/icu4c/source/common/characterproperties.cpp b/icu/icu/icu4c/source/common/characterproperties.cpp
index 7b50a4e2..ba62d94d 100644
--- a/icu/icu/icu4c/source/common/characterproperties.cpp
+++ b/icu/icu/icu4c/source/common/characterproperties.cpp
@@ -47,7 +47,10 @@ UnicodeSet *sets[UCHAR_BINARY_LIMIT] = {};
 
 UCPMap *maps[UCHAR_INT_LIMIT - UCHAR_INT_START] = {};
 
-icu::UMutex cpMutex;
+icu::UMutex *cpMutex() {
+    static icu::UMutex m;
+    return &m;
+}
 
 //----------------------------------------------------------------
 // Inclusions list
@@ -358,7 +361,7 @@ u_getBinaryPropertySet(UProperty property, UErrorCode *pErrorCode) {
         *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
         return nullptr;
     }
-    Mutex m(&cpMutex);
+    Mutex m(cpMutex());
     UnicodeSet *set = sets[property];
     if (set == nullptr) {
         sets[property] = set = makeSet(property, *pErrorCode);
@@ -374,7 +377,7 @@ u_getIntPropertyMap(UProperty property, UErrorCode *pErrorCode) {
         *pErrorCode = U_ILLEGAL_ARGUMENT_ERROR;
         return nullptr;
     }
-    Mutex m(&cpMutex);
+    Mutex m(cpMutex());
     UCPMap *map = maps[property - UCHAR_INT_START];
     if (map == nullptr) {
         maps[property - UCHAR_INT_START] = map = makeMap(property, *pErrorCode);
diff --git a/icu/icu/icu4c/source/common/locid.cpp b/icu/icu/icu4c/source/common/locid.cpp
index 5868b5eb..93611aad 100644
--- a/icu/icu/icu4c/source/common/locid.cpp
+++ b/icu/icu/icu4c/source/common/locid.cpp
@@ -62,7 +62,10 @@ static Locale   *gLocaleCache = NULL;
 static UInitOnce gLocaleCacheInitOnce = U_INITONCE_INITIALIZER;
 
 // gDefaultLocaleMutex protects all access to gDefaultLocalesHashT and gDefaultLocale.
-static UMutex gDefaultLocaleMutex;
+static UMutex *gDefaultLocaleMutex() {
+    static UMutex m;
+    return &m;
+}
 static UHashtable *gDefaultLocalesHashT = NULL;
 static Locale *gDefaultLocale = NULL;
 
@@ -171,7 +174,7 @@ U_NAMESPACE_BEGIN
 
 Locale *locale_set_default_internal(const char *id, UErrorCode& status) {
     // Synchronize this entire function.
-    Mutex lock(&gDefaultLocaleMutex);
+    Mutex lock(gDefaultLocaleMutex());
 
     UBool canonicalize = FALSE;
 
@@ -708,7 +711,7 @@ const Locale& U_EXPORT2
 Locale::getDefault()
 {
     {
-        Mutex lock(&gDefaultLocaleMutex);
+        Mutex lock(gDefaultLocaleMutex());
         if (gDefaultLocale != NULL) {
             return *gDefaultLocale;
         }
diff --git a/icu/icu/icu4c/source/common/serv.cpp b/icu/icu/icu4c/source/common/serv.cpp
index ce545b9d..599122ed 100644
--- a/icu/icu/icu4c/source/common/serv.cpp
+++ b/icu/icu/icu4c/source/common/serv.cpp
@@ -333,7 +333,10 @@ U_CDECL_END
 ******************************************************************
 */
 
-static UMutex lock;
+static UMutex *lock() {
+    static UMutex m;
+    return &m;
+}
 
 ICUService::ICUService()
 : name()
@@ -358,7 +361,7 @@ ICUService::ICUService(const UnicodeString& newName)
 ICUService::~ICUService()
 {
     {
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
         clearCaches();
         delete factories;
         factories = NULL;
@@ -449,7 +452,7 @@ ICUService::getKey(ICUServiceKey& key, UnicodeString* actualReturn, const ICUSer
         // if factory is not null, we're calling from within the mutex,
         // and since some unix machines don't have reentrant mutexes we
         // need to make sure not to try to lock it again.
-        XMutex mutex(&lock, factory != NULL);
+        XMutex mutex(lock(), factory != NULL);
 
         if (serviceCache == NULL) {
             ncthis->serviceCache = new Hashtable(status);
@@ -615,7 +618,7 @@ ICUService::getVisibleIDs(UVector& result, const UnicodeString* matchID, UErrorC
     }
 
     {
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
         const Hashtable* map = getVisibleIDMap(status);
         if (map != NULL) {
             ICUServiceKey* fallbackKey = createKey(matchID, status);
@@ -692,7 +695,7 @@ ICUService::getDisplayName(const UnicodeString& id, UnicodeString& result, const
 {
     {
         UErrorCode status = U_ZERO_ERROR;
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
         const Hashtable* map = getVisibleIDMap(status);
         if (map != NULL) {
             ICUServiceFactory* f = (ICUServiceFactory*)map->get(id);
@@ -744,7 +747,7 @@ ICUService::getDisplayNames(UVector& result,
     result.setDeleter(userv_deleteStringPair);
     if (U_SUCCESS(status)) {
         ICUService* ncthis = (ICUService*)this; // cast away semantic const
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
 
         if (dnCache != NULL && dnCache->locale != locale) {
             delete dnCache;
@@ -849,7 +852,7 @@ URegistryKey
 ICUService::registerFactory(ICUServiceFactory* factoryToAdopt, UErrorCode& status) 
 {
     if (U_SUCCESS(status) && factoryToAdopt != NULL) {
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
 
         if (factories == NULL) {
             factories = new UVector(deleteUObject, NULL, status);
@@ -880,7 +883,7 @@ ICUService::unregister(URegistryKey rkey, UErrorCode& status)
     ICUServiceFactory *factory = (ICUServiceFactory*)rkey;
     UBool result = FALSE;
     if (factory != NULL && factories != NULL) {
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
 
         if (factories->removeElement(factory)) {
             clearCaches();
@@ -900,7 +903,7 @@ void
 ICUService::reset() 
 {
     {
-        Mutex mutex(&lock);
+        Mutex mutex(lock());
         reInitializeFactories();
         clearCaches();
     }
diff --git a/icu/icu/icu4c/source/common/servnotf.cpp b/icu/icu/icu4c/source/common/servnotf.cpp
index f577795c..3949bf64 100644
--- a/icu/icu/icu4c/source/common/servnotf.cpp
+++ b/icu/icu/icu4c/source/common/servnotf.cpp
@@ -21,7 +21,10 @@ U_NAMESPACE_BEGIN
 EventListener::~EventListener() {}
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(EventListener)
 
-static UMutex notifyLock;
+static UMutex *notifyLock() {
+    static UMutex m;
+    return &m;
+}
 
 ICUNotifier::ICUNotifier(void) 
 : listeners(NULL) 
@@ -30,7 +33,7 @@ ICUNotifier::ICUNotifier(void)
 
 ICUNotifier::~ICUNotifier(void) {
     {
-        Mutex lmx(&notifyLock);
+        Mutex lmx(notifyLock());
         delete listeners;
         listeners = NULL;
     }
@@ -47,7 +50,7 @@ ICUNotifier::addListener(const EventListener* l, UErrorCode& status)
         }
 
         if (acceptsListener(*l)) {
-            Mutex lmx(&notifyLock);
+            Mutex lmx(notifyLock());
             if (listeners == NULL) {
                 listeners = new UVector(5, status);
             } else {
@@ -80,7 +83,7 @@ ICUNotifier::removeListener(const EventListener *l, UErrorCode& status)
         }
 
         {
-            Mutex lmx(&notifyLock);
+            Mutex lmx(notifyLock());
             if (listeners != NULL) {
                 // identity equality check
                 for (int i = 0, e = listeners->size(); i < e; ++i) {
@@ -103,7 +106,7 @@ void
 ICUNotifier::notifyChanged(void) 
 {
     if (listeners != NULL) {
-        Mutex lmx(&notifyLock);
+        Mutex lmx(notifyLock());
         if (listeners != NULL) {
             for (int i = 0, e = listeners->size(); i < e; ++i) {
                 EventListener* el = (EventListener*)listeners->elementAt(i);
diff --git a/icu/icu/icu4c/source/common/ucnv_bld.cpp b/icu/icu/icu4c/source/common/ucnv_bld.cpp
index 56fc3d68..aa096e4e 100644
--- a/icu/icu/icu4c/source/common/ucnv_bld.cpp
+++ b/icu/icu/icu4c/source/common/ucnv_bld.cpp
@@ -194,7 +194,10 @@ static struct {
 
 /*initializes some global variables */
 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
-static icu::UMutex cnvCacheMutex;
+static icu::UMutex *cnvCacheMutex() {                 /* Mutex for synchronizing cnv cache access. */
+    static icu::UMutex m;
+    return &m;
+}
 /*  Note:  the global mutex is used for      */
 /*         reference count updates.          */
 
@@ -599,9 +602,9 @@ U_CFUNC void
 ucnv_unloadSharedDataIfReady(UConverterSharedData *sharedData)
 {
     if(sharedData != NULL && sharedData->isReferenceCounted) {
-        umtx_lock(&cnvCacheMutex);
+        umtx_lock(cnvCacheMutex());
         ucnv_unload(sharedData);
-        umtx_unlock(&cnvCacheMutex);
+        umtx_unlock(cnvCacheMutex());
     }
 }
 
@@ -609,9 +612,9 @@ U_CFUNC void
 ucnv_incrementRefCount(UConverterSharedData *sharedData)
 {
     if(sharedData != NULL && sharedData->isReferenceCounted) {
-        umtx_lock(&cnvCacheMutex);
+        umtx_lock(cnvCacheMutex());
         sharedData->referenceCounter++;
-        umtx_unlock(&cnvCacheMutex);
+        umtx_unlock(cnvCacheMutex());
     }
 }
 
@@ -812,9 +815,9 @@ ucnv_loadSharedData(const char *converterName,
         pArgs->nestedLoads=1;
         pArgs->pkg=NULL;
 
-        umtx_lock(&cnvCacheMutex);
+        umtx_lock(cnvCacheMutex());
         mySharedConverterData = ucnv_load(pArgs, err);
-        umtx_unlock(&cnvCacheMutex);
+        umtx_unlock(cnvCacheMutex());
         if (U_FAILURE (*err) || (mySharedConverterData == NULL))
         {
             return NULL;
@@ -1061,7 +1064,7 @@ ucnv_flushCache ()
     *                   because the sequence of looking up in the cache + incrementing
     *                   is protected by cnvCacheMutex.
     */
-    umtx_lock(&cnvCacheMutex);
+    umtx_lock(cnvCacheMutex());
     /*
      * double loop: A delta/extension-only converter has a pointer to its base table's
      * shared data; the first iteration of the outer loop may see the delta converter
@@ -1090,7 +1093,7 @@ ucnv_flushCache ()
             }
         }
     } while(++i == 1 && remaining > 0);
-    umtx_unlock(&cnvCacheMutex);
+    umtx_unlock(cnvCacheMutex());
 
     UTRACE_DATA1(UTRACE_INFO, "ucnv_flushCache() exits with %d converters remaining", remaining);
 
@@ -1196,7 +1199,7 @@ internalSetName(const char *name, UErrorCode *status) {
     }
     algorithmicSharedData = getAlgorithmicTypeFromName(stackArgs.name);
 
-    umtx_lock(&cnvCacheMutex);
+    umtx_lock(cnvCacheMutex());
 
     gDefaultAlgorithmicSharedData = algorithmicSharedData;
     gDefaultConverterContainsOption = containsOption;
@@ -1212,7 +1215,7 @@ internalSetName(const char *name, UErrorCode *status) {
 
     ucnv_enableCleanup();
 
-    umtx_unlock(&cnvCacheMutex);
+    umtx_unlock(cnvCacheMutex());
 }
 #endif
 
@@ -1237,7 +1240,7 @@ ucnv_getDefaultName() {
     but ucnv_setDefaultName is not thread safe.
     */
     {
-        icu::Mutex lock(&cnvCacheMutex);
+        icu::Mutex lock(cnvCacheMutex());
         name = gDefaultConverterName;
     }
     if(name==NULL) {
diff --git a/icu/icu/icu4c/source/common/ucurr.cpp b/icu/icu/icu4c/source/common/ucurr.cpp
index 81176459..c08b2924 100644
--- a/icu/icu/icu4c/source/common/ucurr.cpp
+++ b/icu/icu/icu4c/source/common/ucurr.cpp
@@ -365,7 +365,10 @@ U_CDECL_END
 #if !UCONFIG_NO_SERVICE
 struct CReg;
 
-static UMutex gCRegLock;
+static UMutex *gCRegLock() {
+    static UMutex m;
+    return &m;
+}
 static CReg* gCRegHead = 0;
 
 struct CReg : public icu::UMemory {
@@ -391,14 +394,14 @@ struct CReg : public icu::UMemory {
         if (status && U_SUCCESS(*status) && _iso && _id) {
             CReg* n = new CReg(_iso, _id);
             if (n) {
-                umtx_lock(&gCRegLock);
+                umtx_lock(gCRegLock());
                 if (!gCRegHead) {
                     /* register for the first time */
                     ucln_common_registerCleanup(UCLN_COMMON_CURRENCY, currency_cleanup);
                 }
                 n->next = gCRegHead;
                 gCRegHead = n;
-                umtx_unlock(&gCRegLock);
+                umtx_unlock(gCRegLock());
                 return n;
             }
             *status = U_MEMORY_ALLOCATION_ERROR;
@@ -408,7 +411,7 @@ struct CReg : public icu::UMemory {
 
     static UBool unreg(UCurrRegistryKey key) {
         UBool found = FALSE;
-        umtx_lock(&gCRegLock);
+        umtx_lock(gCRegLock());
 
         CReg** p = &gCRegHead;
         while (*p) {
@@ -421,13 +424,13 @@ struct CReg : public icu::UMemory {
             p = &((*p)->next);
         }
 
-        umtx_unlock(&gCRegLock);
+        umtx_unlock(gCRegLock());
         return found;
     }
 
     static const UChar* get(const char* id) {
         const UChar* result = NULL;
-        umtx_lock(&gCRegLock);
+        umtx_lock(gCRegLock());
         CReg* p = gCRegHead;
 
         /* register cleanup of the mutex */
@@ -439,7 +442,7 @@ struct CReg : public icu::UMemory {
             }
             p = p->next;
         }
-        umtx_unlock(&gCRegLock);
+        umtx_unlock(gCRegLock());
         return result;
     }
 
@@ -1353,7 +1356,10 @@ static CurrencyNameCacheEntry* currCache[CURRENCY_NAME_CACHE_NUM] = {NULL};
 // It is a simple round-robin replacement strategy.
 static int8_t currentCacheEntryIndex = 0;
 
-static UMutex gCurrencyCacheMutex;
+static UMutex *gCurrencyCacheMutex() {
+    static UMutex m;
+    return &m;
+}
 
 // Cache deletion
 static void
@@ -1402,7 +1408,7 @@ getCacheEntry(const char* locale, UErrorCode& ec) {
     CurrencyNameStruct* currencySymbols = NULL;
     CurrencyNameCacheEntry* cacheEntry = NULL;
 
-    umtx_lock(&gCurrencyCacheMutex);
+    umtx_lock(gCurrencyCacheMutex());
     // in order to handle racing correctly,
     // not putting 'search' in a separate function.
     int8_t found = -1;
@@ -1417,13 +1423,13 @@ getCacheEntry(const char* locale, UErrorCode& ec) {
         cacheEntry = currCache[found];
         ++(cacheEntry->refCount);
     }
-    umtx_unlock(&gCurrencyCacheMutex);
+    umtx_unlock(gCurrencyCacheMutex());
     if (found == -1) {
         collectCurrencyNames(locale, &currencyNames, &total_currency_name_count, &currencySymbols, &total_currency_symbol_count, ec);
         if (U_FAILURE(ec)) {
             return NULL;
         }
-        umtx_lock(&gCurrencyCacheMutex);
+        umtx_lock(gCurrencyCacheMutex());
         // check again.
         for (int8_t i = 0; i < CURRENCY_NAME_CACHE_NUM; ++i) {
             if (currCache[i]!= NULL &&
@@ -1462,19 +1468,19 @@ getCacheEntry(const char* locale, UErrorCode& ec) {
             cacheEntry = currCache[found];
             ++(cacheEntry->refCount);
         }
-        umtx_unlock(&gCurrencyCacheMutex);
+        umtx_unlock(gCurrencyCacheMutex());
     }
 
     return cacheEntry;
 }
 
 static void releaseCacheEntry(CurrencyNameCacheEntry* cacheEntry) {
-    umtx_lock(&gCurrencyCacheMutex);
+    umtx_lock(gCurrencyCacheMutex());
     --(cacheEntry->refCount);
     if (cacheEntry->refCount == 0) {  // remove
         deleteCacheEntry(cacheEntry);
     }
-    umtx_unlock(&gCurrencyCacheMutex);
+    umtx_unlock(gCurrencyCacheMutex());
 }
 
 U_CAPI void
diff --git a/icu/icu/icu4c/source/common/umutex.cpp b/icu/icu/icu4c/source/common/umutex.cpp
index c176e2af..c3e958fe 100644
--- a/icu/icu/icu4c/source/common/umutex.cpp
+++ b/icu/icu/icu4c/source/common/umutex.cpp
@@ -49,7 +49,10 @@ std::condition_variable *initCondition;
 
 // The ICU global mutex.
 // Used when ICU implementation code passes nullptr for the mutex pointer.
-UMutex globalMutex;
+static UMutex *globalMutex() {
+    static UMutex m;
+    return &m;
+}
 
 std::once_flag initFlag;
 std::once_flag *pInitFlag = &initFlag;
@@ -109,7 +112,7 @@ void UMutex::cleanup() {
 U_CAPI void  U_EXPORT2
 umtx_lock(UMutex *mutex) {
     if (mutex == nullptr) {
-        mutex = &globalMutex;
+        mutex = globalMutex();
     }
     mutex->lock();
 }
@@ -119,7 +122,7 @@ U_CAPI void  U_EXPORT2
 umtx_unlock(UMutex* mutex)
 {
     if (mutex == nullptr) {
-        mutex = &globalMutex;
+        mutex = globalMutex();
     }
     mutex->unlock();
 }
diff --git a/icu/icu/icu4c/source/common/uresbund.cpp b/icu/icu/icu4c/source/common/uresbund.cpp
index 57d133ed..4e63ed49 100644
--- a/icu/icu/icu4c/source/common/uresbund.cpp
+++ b/icu/icu/icu4c/source/common/uresbund.cpp
@@ -50,7 +50,10 @@ TODO: This cache should probably be removed when the deprecated code is
 static UHashtable *cache = NULL;
 static icu::UInitOnce gCacheInitOnce = U_INITONCE_INITIALIZER;
 
-static UMutex resbMutex;
+static UMutex *resbMutex() {
+    static UMutex m;
+    return &m;
+}
 
 /* INTERNAL: hashes an entry  */
 static int32_t U_CALLCONV hashEntry(const UHashTok parm) {
@@ -94,7 +97,7 @@ static UBool chopLocale(char *name) {
  *  Internal function
  */
 static void entryIncrease(UResourceDataEntry *entry) {
-    Mutex lock(&resbMutex);
+    Mutex lock(resbMutex());
     entry->fCountExisting++;
     while(entry->fParent != NULL) {
       entry = entry->fParent;
@@ -181,7 +184,7 @@ static int32_t ures_flushCache()
     /*if shared data hasn't even been lazy evaluated yet
     * return 0
     */
-    Mutex lock(&resbMutex);
+    Mutex lock(resbMutex());
     if (cache == NULL) {
         return 0;
     }
@@ -227,7 +230,7 @@ U_CAPI UBool U_EXPORT2 ures_dumpCacheContents(void) {
   const UHashElement *e;
   UResourceDataEntry *resB;
   
-    Mutex lock(&resbMutex);
+    Mutex lock(resbMutex());
     if (cache == NULL) {
       fprintf(stderr,"%s:%d: RB Cache is NULL.\n", __FILE__, __LINE__);
       return FALSE;
@@ -657,7 +660,7 @@ static UResourceDataEntry *entryOpen(const char* path, const char* localeID,
         }
     }
  
-    Mutex lock(&resbMutex);    // Lock resbMutex until the end of this function.
+    Mutex lock(resbMutex());    // Lock resbMutex until the end of this function.
 
     /* We're going to skip all the locales that do not have any data */
     r = findFirstExisting(path, name, &isRoot, &hasChopped, &isDefault, &intStatus);
@@ -779,7 +782,7 @@ entryOpenDirect(const char* path, const char* localeID, UErrorCode* status) {
         return NULL;
     }
 
-    Mutex lock(&resbMutex);
+    Mutex lock(resbMutex());
     // findFirstExisting() without fallbacks.
     UResourceDataEntry *r = init_entry(localeID, path, status);
     if(U_SUCCESS(*status)) {
@@ -859,7 +862,7 @@ static void entryCloseInt(UResourceDataEntry *resB) {
  */
 
 static void entryClose(UResourceDataEntry *resB) {
-  Mutex lock(&resbMutex);
+  Mutex lock(resbMutex());
   entryCloseInt(resB);
 }
 
diff --git a/icu/icu/icu4c/source/common/usprep.cpp b/icu/icu/icu4c/source/common/usprep.cpp
index 8351a773..6ad227e7 100644
--- a/icu/icu/icu4c/source/common/usprep.cpp
+++ b/icu/icu/icu4c/source/common/usprep.cpp
@@ -47,7 +47,10 @@ Static cache for already opened StringPrep profiles
 static UHashtable *SHARED_DATA_HASHTABLE = NULL;
 static icu::UInitOnce gSharedDataInitOnce = U_INITONCE_INITIALIZER;
 
-static UMutex usprepMutex;
+static UMutex *usprepMutex() {
+    static UMutex m;
+    return &m;
+}
 /* format version of spp file */
 //static uint8_t formatVersion[4]={ 0, 0, 0, 0 };
 
@@ -147,9 +150,9 @@ usprep_internal_flushCache(UBool noRefCount){
      * if shared data hasn't even been lazy evaluated yet
      * return 0
      */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     if (SHARED_DATA_HASHTABLE == NULL) {
-        umtx_unlock(&usprepMutex);
+        umtx_unlock(usprepMutex());
         return 0;
     }
 
@@ -180,7 +183,7 @@ usprep_internal_flushCache(UBool noRefCount){
         }
        
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
 
     return deletedNum;
 }
@@ -258,7 +261,7 @@ loadData(UStringPrepProfile* profile,
     }
 
     /* in the mutex block, set the data for this process */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     if(profile->sprepData==NULL) {
         profile->sprepData=dataMemory;
         dataMemory=NULL;
@@ -267,7 +270,7 @@ loadData(UStringPrepProfile* profile,
     } else {
         p=(const int32_t *)udata_getMemory(profile->sprepData);
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
     /* initialize some variables */
     profile->mappingData=(uint16_t *)((uint8_t *)(p+_SPREP_INDEX_TOP)+profile->indexes[_SPREP_INDEX_TRIE_SIZE]);
     
@@ -324,12 +327,12 @@ usprep_getProfile(const char* path,
     stackKey.path = (char*) path;
 
     /* fetch the data from the cache */
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&stackKey));
     if(profile != NULL) {
         profile->refCount++;
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
     
     if(profile == NULL) {
         /* else load the data and put the data in the cache */
@@ -361,7 +364,7 @@ usprep_getProfile(const char* path,
             return NULL;
         }
 
-        umtx_lock(&usprepMutex);
+        umtx_lock(usprepMutex());
         // If another thread already inserted the same key/value, refcount and cleanup our thread data
         profile = (UStringPrepProfile*) (uhash_get(SHARED_DATA_HASHTABLE,&stackKey));
         if(profile != NULL) {
@@ -382,7 +385,7 @@ usprep_getProfile(const char* path,
             profile->refCount = 1;
             uhash_put(SHARED_DATA_HASHTABLE, key.orphan(), profile, status);
         }
-        umtx_unlock(&usprepMutex);
+        umtx_unlock(usprepMutex());
     }
 
     return profile;
@@ -421,12 +424,12 @@ usprep_close(UStringPrepProfile* profile){
         return;
     }
 
-    umtx_lock(&usprepMutex);
+    umtx_lock(usprepMutex());
     /* decrement the ref count*/
     if(profile->refCount > 0){
         profile->refCount--;
     }
-    umtx_unlock(&usprepMutex);
+    umtx_unlock(usprepMutex());
     
 }
 
diff --git a/icu/icu/icu4c/source/i18n/astro.cpp b/icu/icu/icu4c/source/i18n/astro.cpp
index f17b6db9..c21c6e0a 100644
--- a/icu/icu/icu4c/source/i18n/astro.cpp
+++ b/icu/icu/icu4c/source/i18n/astro.cpp
@@ -65,7 +65,10 @@ static inline UBool isINVALID(double d) {
   return(uprv_isNaN(d));
 }
 
-static icu::UMutex ccLock;
+static icu::UMutex *ccLock() {
+    static icu::UMutex m;
+    return &m;
+}
 
 U_CDECL_BEGIN
 static UBool calendar_astro_cleanup(void) {
@@ -1549,12 +1552,12 @@ int32_t CalendarCache::get(CalendarCache** cache, int32_t key, UErrorCode &statu
     if(U_FAILURE(status)) {
         return 0;
     }
-    umtx_lock(&ccLock);
+    umtx_lock(ccLock());
 
     if(*cache == NULL) {
         createCache(cache, status);
         if(U_FAILURE(status)) {
-            umtx_unlock(&ccLock);
+            umtx_unlock(ccLock());
             return 0;
         }
     }
@@ -1562,7 +1565,7 @@ int32_t CalendarCache::get(CalendarCache** cache, int32_t key, UErrorCode &statu
     res = uhash_igeti((*cache)->fTable, key);
     U_DEBUG_ASTRO_MSG(("%p: GET: [%d] == %d\n", (*cache)->fTable, key, res));
 
-    umtx_unlock(&ccLock);
+    umtx_unlock(ccLock());
     return res;
 }
 
@@ -1570,12 +1573,12 @@ void CalendarCache::put(CalendarCache** cache, int32_t key, int32_t value, UErro
     if(U_FAILURE(status)) {
         return;
     }
-    umtx_lock(&ccLock);
+    umtx_lock(ccLock());
 
     if(*cache == NULL) {
         createCache(cache, status);
         if(U_FAILURE(status)) {
-            umtx_unlock(&ccLock);
+            umtx_unlock(ccLock());
             return;
         }
     }
@@ -1583,7 +1586,7 @@ void CalendarCache::put(CalendarCache** cache, int32_t key, int32_t value, UErro
     uhash_iputi((*cache)->fTable, key, value, &status);
     U_DEBUG_ASTRO_MSG(("%p: PUT: [%d] := %d\n", (*cache)->fTable, key, value));
 
-    umtx_unlock(&ccLock);
+    umtx_unlock(ccLock());
 }
 
 CalendarCache::CalendarCache(int32_t size, UErrorCode &status) {
diff --git a/icu/icu/icu4c/source/i18n/chnsecal.cpp b/icu/icu/icu4c/source/i18n/chnsecal.cpp
index bd85db18..d8e6f50d 100644
--- a/icu/icu/icu4c/source/i18n/chnsecal.cpp
+++ b/icu/icu/icu4c/source/i18n/chnsecal.cpp
@@ -51,7 +51,10 @@ static void debug_chnsecal_msg(const char *pat, ...)
 
 
 // --- The cache --
-static icu::UMutex astroLock;
+static icu::UMutex *astroLock() {  // Protects access to gChineseCalendarAstro.
+    static icu::UMutex m;
+    return &m;
+}
 static icu::CalendarAstronomer *gChineseCalendarAstro = NULL;
 
 // Lazy Creation & Access synchronized by class CalendarCache with a mutex.
@@ -535,14 +538,14 @@ int32_t ChineseCalendar::winterSolstice(int32_t gyear) const {
         // PST 1298 with a final result of Dec 14 10:31:59 PST 1299.
         double ms = daysToMillis(Grego::fieldsToDay(gyear, UCAL_DECEMBER, 1));
 
-        umtx_lock(&astroLock);
+        umtx_lock(astroLock());
         if(gChineseCalendarAstro == NULL) {
             gChineseCalendarAstro = new CalendarAstronomer();
             ucln_i18n_registerCleanup(UCLN_I18N_CHINESE_CALENDAR, calendar_chinese_cleanup);
         }
         gChineseCalendarAstro->setTime(ms);
         UDate solarLong = gChineseCalendarAstro->getSunTime(CalendarAstronomer::WINTER_SOLSTICE(), TRUE);
-        umtx_unlock(&astroLock);
+        umtx_unlock(astroLock());
 
         // Winter solstice is 270 degrees solar longitude aka Dongzhi
         cacheValue = (int32_t)millisToDays(solarLong);
@@ -565,14 +568,14 @@ int32_t ChineseCalendar::winterSolstice(int32_t gyear) const {
  */
 int32_t ChineseCalendar::newMoonNear(double days, UBool after) const {
     
-    umtx_lock(&astroLock);
+    umtx_lock(astroLock());
     if(gChineseCalendarAstro == NULL) {
         gChineseCalendarAstro = new CalendarAstronomer();
         ucln_i18n_registerCleanup(UCLN_I18N_CHINESE_CALENDAR, calendar_chinese_cleanup);
     }
     gChineseCalendarAstro->setTime(daysToMillis(days));
     UDate newMoon = gChineseCalendarAstro->getMoonTime(CalendarAstronomer::NEW_MOON(), after);
-    umtx_unlock(&astroLock);
+    umtx_unlock(astroLock());
     
     return (int32_t) millisToDays(newMoon);
 }
@@ -597,14 +600,14 @@ int32_t ChineseCalendar::synodicMonthsBetween(int32_t day1, int32_t day2) const
  */
 int32_t ChineseCalendar::majorSolarTerm(int32_t days) const {
     
-    umtx_lock(&astroLock);
+    umtx_lock(astroLock());
     if(gChineseCalendarAstro == NULL) {
         gChineseCalendarAstro = new CalendarAstronomer();
         ucln_i18n_registerCleanup(UCLN_I18N_CHINESE_CALENDAR, calendar_chinese_cleanup);
     }
     gChineseCalendarAstro->setTime(daysToMillis(days));
     UDate solarLongitude = gChineseCalendarAstro->getSunLongitude();
-    umtx_unlock(&astroLock);
+    umtx_unlock(astroLock());
 
     // Compute (floor(solarLongitude / (pi/6)) + 2) % 12
     int32_t term = ( ((int32_t)(6 * solarLongitude / CalendarAstronomer::PI)) + 2 ) % 12;
diff --git a/icu/icu/icu4c/source/i18n/dtitvfmt.cpp b/icu/icu/icu4c/source/i18n/dtitvfmt.cpp
index f5d86944..587019b4 100644
--- a/icu/icu/icu4c/source/i18n/dtitvfmt.cpp
+++ b/icu/icu/icu4c/source/i18n/dtitvfmt.cpp
@@ -82,7 +82,10 @@ UOBJECT_DEFINE_RTTI_IMPLEMENTATION(DateIntervalFormat)
 // Mutex, protects access to fDateFormat, fFromCalendar and fToCalendar.
 //        Needed because these data members are modified by const methods of DateIntervalFormat.
 
-static UMutex gFormatterMutex;
+static UMutex *gFormatterMutex() {
+    static UMutex m;
+    return &m;
+}
 
 DateIntervalFormat* U_EXPORT2
 DateIntervalFormat::createInstance(const UnicodeString& skeleton,
@@ -168,7 +171,7 @@ DateIntervalFormat::operator=(const DateIntervalFormat& itvfmt) {
         delete fTimePattern;
         delete fDateTimeFormat;
         {
-            Mutex lock(&gFormatterMutex);
+            Mutex lock(gFormatterMutex());
             if ( itvfmt.fDateFormat ) {
                 fDateFormat = (SimpleDateFormat*)itvfmt.fDateFormat->clone();
             } else {
@@ -230,7 +233,7 @@ DateIntervalFormat::operator==(const Format& other) const {
     if ((fInfo != fmt->fInfo) && (fInfo == NULL || fmt->fInfo == NULL)) {return FALSE;}
     if (fInfo && fmt->fInfo && (*fInfo != *fmt->fInfo )) {return FALSE;}
     {
-        Mutex lock(&gFormatterMutex);
+        Mutex lock(gFormatterMutex());
         if (fDateFormat != fmt->fDateFormat && (fDateFormat == NULL || fmt->fDateFormat == NULL)) {return FALSE;}
         if (fDateFormat && fmt->fDateFormat && (*fDateFormat != *fmt->fDateFormat)) {return FALSE;}
     }
@@ -292,7 +295,7 @@ DateIntervalFormat::format(const DateInterval* dtInterval,
     handler.setAcceptFirstOnly(TRUE);
     int8_t ignore;
 
-    Mutex lock(&gFormatterMutex);
+    Mutex lock(gFormatterMutex());
     return formatIntervalImpl(*dtInterval, appendTo, ignore, handler, status);
 }
 
@@ -309,7 +312,7 @@ FormattedDateInterval DateIntervalFormat::formatToValue(
     auto handler = result->getHandler(status);
     handler.setCategory(UFIELD_CATEGORY_DATE);
     {
-        Mutex lock(&gFormatterMutex);
+        Mutex lock(gFormatterMutex());
         formatIntervalImpl(dtInterval, string, firstIndex, handler, status);
     }
     handler.getError(status);
@@ -341,7 +344,7 @@ DateIntervalFormat::format(Calendar& fromCalendar,
     handler.setAcceptFirstOnly(TRUE);
     int8_t ignore;
 
-    Mutex lock(&gFormatterMutex);
+    Mutex lock(gFormatterMutex());
     return formatImpl(fromCalendar, toCalendar, appendTo, ignore, handler, status);
 }
 
@@ -359,7 +362,7 @@ FormattedDateInterval DateIntervalFormat::formatToValue(
     auto handler = result->getHandler(status);
     handler.setCategory(UFIELD_CATEGORY_DATE);
     {
-        Mutex lock(&gFormatterMutex);
+        Mutex lock(gFormatterMutex());
         formatImpl(fromCalendar, toCalendar, string, firstIndex, handler, status);
     }
     handler.getError(status);
@@ -597,7 +600,7 @@ const TimeZone&
 DateIntervalFormat::getTimeZone() const
 {
     if (fDateFormat != NULL) {
-        Mutex lock(&gFormatterMutex);
+        Mutex lock(gFormatterMutex());
         return fDateFormat->getTimeZone();
     }
     // If fDateFormat is NULL (unexpected), create default timezone.
diff --git a/icu/icu/icu4c/source/i18n/smpdtfmt.cpp b/icu/icu/icu4c/source/i18n/smpdtfmt.cpp
index 49c3a409..2d589ef6 100644
--- a/icu/icu/icu4c/source/i18n/smpdtfmt.cpp
+++ b/icu/icu/icu4c/source/i18n/smpdtfmt.cpp
@@ -230,7 +230,10 @@ static const int32_t gFieldRangeBias[] = {
 static const int32_t HEBREW_CAL_CUR_MILLENIUM_START_YEAR = 5000;
 static const int32_t HEBREW_CAL_CUR_MILLENIUM_END_YEAR = 6000;
 
-static UMutex LOCK;
+static UMutex *LOCK() {
+    static UMutex m;
+    return &m;
+}
 
 UOBJECT_DEFINE_RTTI_IMPLEMENTATION(SimpleDateFormat)
 
@@ -1263,14 +1266,14 @@ SimpleDateFormat::initNumberFormatters(const Locale &locale,UErrorCode &status)
     if ( fDateOverride.isBogus() && fTimeOverride.isBogus() ) {
         return;
     }
-    umtx_lock(&LOCK);
+    umtx_lock(LOCK());
     if (fSharedNumberFormatters == NULL) {
         fSharedNumberFormatters = allocSharedNumberFormatters();
         if (fSharedNumberFormatters == NULL) {
             status = U_MEMORY_ALLOCATION_ERROR;
         }
     }
-    umtx_unlock(&LOCK);
+    umtx_unlock(LOCK());
 
     if (U_FAILURE(status)) {
         return;
@@ -3898,11 +3901,11 @@ SimpleDateFormat::applyPattern(const UnicodeString& pattern)
         } else if (fDateOverride.isBogus() && fHasHanYearChar) {
             // No current override (=> no Gannen numbering) but new pattern needs it;
             // use procedures from initNUmberFormatters / adoptNumberFormat
-            umtx_lock(&LOCK);
+            umtx_lock(LOCK());
             if (fSharedNumberFormatters == NULL) {
                 fSharedNumberFormatters = allocSharedNumberFormatters();
             }
-            umtx_unlock(&LOCK);
+            umtx_unlock(LOCK());
             if (fSharedNumberFormatters != NULL) {
                 Locale ovrLoc(fLocale.getLanguage(),fLocale.getCountry(),fLocale.getVariant(),"numbers=jpanyear");
                 UErrorCode status = U_ZERO_ERROR;
@@ -4235,7 +4238,7 @@ SimpleDateFormat::skipUWhiteSpace(const UnicodeString& text, int32_t pos) const
 TimeZoneFormat *
 SimpleDateFormat::tzFormat(UErrorCode &status) const {
     if (fTimeZoneFormat == NULL) {
-        umtx_lock(&LOCK);
+        umtx_lock(LOCK());
         {
             if (fTimeZoneFormat == NULL) {
                 TimeZoneFormat *tzfmt = TimeZoneFormat::createInstance(fLocale, status);
@@ -4246,7 +4249,7 @@ SimpleDateFormat::tzFormat(UErrorCode &status) const {
                 const_cast<SimpleDateFormat *>(this)->fTimeZoneFormat = tzfmt;
             }
         }
-        umtx_unlock(&LOCK);
+        umtx_unlock(LOCK());
     }
     return fTimeZoneFormat;
 }
diff --git a/icu/icu/icu4c/source/i18n/timezone.cpp b/icu/icu/icu4c/source/i18n/timezone.cpp
index 284334eb..72dd2935 100644
--- a/icu/icu/icu4c/source/i18n/timezone.cpp
+++ b/icu/icu/icu4c/source/i18n/timezone.cpp
@@ -527,7 +527,10 @@ TimeZone::detectHostTimeZone()
 
 // -------------------------------------
 
-static UMutex gDefaultZoneMutex;
+static UMutex *gDefaultZoneMutex() {
+    static UMutex m;
+    return &m;
+}
 
 /**
  * Initialize DEFAULT_ZONE from the system default time zone.  
@@ -538,7 +541,7 @@ static void U_CALLCONV initDefault()
 {
     ucln_i18n_registerCleanup(UCLN_I18N_TIMEZONE, timeZone_cleanup);
 
-    Mutex lock(&gDefaultZoneMutex);
+    Mutex lock(gDefaultZoneMutex());
     // If setDefault() has already been called we can skip getting the
     // default zone information from the system.
     if (DEFAULT_ZONE != NULL) {
@@ -572,7 +575,7 @@ TimeZone::createDefault()
 {
     umtx_initOnce(gDefaultZoneInitOnce, initDefault);
     {
-        Mutex lock(&gDefaultZoneMutex);
+        Mutex lock(gDefaultZoneMutex());
         return (DEFAULT_ZONE != NULL) ? DEFAULT_ZONE->clone() : NULL;
     }
 }
@@ -585,7 +588,7 @@ TimeZone::adoptDefault(TimeZone* zone)
     if (zone != NULL)
     {
         {
-            Mutex lock(&gDefaultZoneMutex);
+            Mutex lock(gDefaultZoneMutex());
             TimeZone *old = DEFAULT_ZONE;
             DEFAULT_ZONE = zone;
             delete old;
diff --git a/icu/icu/icu4c/source/i18n/translit.cpp b/icu/icu/icu4c/source/i18n/translit.cpp
index 3feb0a3b..14553d47 100644
--- a/icu/icu/icu4c/source/i18n/translit.cpp
+++ b/icu/icu/icu4c/source/i18n/translit.cpp
@@ -91,7 +91,10 @@ static const char RB_RULE_BASED_IDS[] = "RuleBasedTransliteratorIDs";
 /**
  * The mutex controlling access to registry object.
  */
-static icu::UMutex registryMutex;
+static icu::UMutex *registryMutex() {
+    static icu::UMutex m;
+    return &m;
+}
 
 /**
  * System transliterator registry; non-null when initialized.
@@ -978,11 +981,11 @@ Transliterator* Transliterator::createBasicInstance(const UnicodeString& id,
     TransliteratorAlias* alias = 0;
     Transliterator* t = 0;
 
-    umtx_lock(&registryMutex);
+    umtx_lock(registryMutex());
     if (HAVE_REGISTRY(ec)) {
         t = registry->get(id, alias, ec);
     }
-    umtx_unlock(&registryMutex);
+    umtx_unlock(registryMutex());
 
     if (U_FAILURE(ec)) {
         delete t;
@@ -1010,11 +1013,11 @@ Transliterator* Transliterator::createBasicInstance(const UnicodeString& id,
             alias = 0;
 
             // Step 2. reget
-            umtx_lock(&registryMutex);
+            umtx_lock(registryMutex());
             if (HAVE_REGISTRY(ec)) {
                 t = registry->reget(id, parser, alias, ec);
             }
-            umtx_unlock(&registryMutex);
+            umtx_unlock(registryMutex());
 
             // Step 3. Loop back around!
         } else {
@@ -1212,7 +1215,7 @@ UnicodeSet& Transliterator::getTargetSet(UnicodeSet& result) const {
 void U_EXPORT2 Transliterator::registerFactory(const UnicodeString& id,
                                      Transliterator::Factory factory,
                                      Transliterator::Token context) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _registerFactory(id, factory, context);
@@ -1251,7 +1254,7 @@ void Transliterator::_registerSpecialInverse(const UnicodeString& target,
  * @see #unregister
  */
 void U_EXPORT2 Transliterator::registerInstance(Transliterator* adoptedPrototype) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _registerInstance(adoptedPrototype);
@@ -1265,7 +1268,7 @@ void Transliterator::_registerInstance(Transliterator* adoptedPrototype) {
 
 void U_EXPORT2 Transliterator::registerAlias(const UnicodeString& aliasID,
                                              const UnicodeString& realID) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _registerAlias(aliasID, realID);
@@ -1287,7 +1290,7 @@ void Transliterator::_registerAlias(const UnicodeString& aliasID,
 
  */
 void U_EXPORT2 Transliterator::unregister(const UnicodeString& ID) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         registry->remove(ID);
@@ -1302,7 +1305,7 @@ void U_EXPORT2 Transliterator::unregister(const UnicodeString& ID) {
  */
 int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
     int32_t retVal = 0;
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         retVal = registry->countAvailableIDs();
@@ -1318,12 +1321,12 @@ int32_t U_EXPORT2 Transliterator::countAvailableIDs(void) {
  */
 const UnicodeString& U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
     const UnicodeString* result = NULL;
-    umtx_lock(&registryMutex);
+    umtx_lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         result = &registry->getAvailableID(index);
     }
-    umtx_unlock(&registryMutex);
+    umtx_unlock(registryMutex());
     U_ASSERT(result != NULL); // fail if no registry
     return *result;
 }
@@ -1331,11 +1334,11 @@ const UnicodeString& U_EXPORT2 Transliterator::getAvailableID(int32_t index) {
 StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode& ec) {
     if (U_FAILURE(ec)) return NULL;
     StringEnumeration* result = NULL;
-    umtx_lock(&registryMutex);
+    umtx_lock(registryMutex());
     if (HAVE_REGISTRY(ec)) {
         result = registry->getAvailableIDs();
     }
-    umtx_unlock(&registryMutex);
+    umtx_unlock(registryMutex());
     if (result == NULL) {
         ec = U_INTERNAL_TRANSLITERATOR_ERROR;
     }
@@ -1343,14 +1346,14 @@ StringEnumeration* U_EXPORT2 Transliterator::getAvailableIDs(UErrorCode& ec) {
 }
 
 int32_t U_EXPORT2 Transliterator::countAvailableSources(void) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     return HAVE_REGISTRY(ec) ? _countAvailableSources() : 0;
 }
 
 UnicodeString& U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
                                                   UnicodeString& result) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _getAvailableSource(index, result);
@@ -1359,7 +1362,7 @@ UnicodeString& U_EXPORT2 Transliterator::getAvailableSource(int32_t index,
 }
 
 int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString& source) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     return HAVE_REGISTRY(ec) ? _countAvailableTargets(source) : 0;
 }
@@ -1367,7 +1370,7 @@ int32_t U_EXPORT2 Transliterator::countAvailableTargets(const UnicodeString& sou
 UnicodeString& U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
                                                   const UnicodeString& source,
                                                   UnicodeString& result) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _getAvailableTarget(index, source, result);
@@ -1377,7 +1380,7 @@ UnicodeString& U_EXPORT2 Transliterator::getAvailableTarget(int32_t index,
 
 int32_t U_EXPORT2 Transliterator::countAvailableVariants(const UnicodeString& source,
                                                const UnicodeString& target) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     return HAVE_REGISTRY(ec) ? _countAvailableVariants(source, target) : 0;
 }
@@ -1386,7 +1389,7 @@ UnicodeString& U_EXPORT2 Transliterator::getAvailableVariant(int32_t index,
                                                    const UnicodeString& source,
                                                    const UnicodeString& target,
                                                    UnicodeString& result) {
-    Mutex lock(&registryMutex);
+    Mutex lock(registryMutex());
     UErrorCode ec = U_ZERO_ERROR;
     if (HAVE_REGISTRY(ec)) {
         _getAvailableVariant(index, source, target, result);
diff --git a/icu/icu/icu4c/source/i18n/tridpars.cpp b/icu/icu/icu4c/source/i18n/tridpars.cpp
index 9de8a167..260840cc 100644
--- a/icu/icu/icu4c/source/i18n/tridpars.cpp
+++ b/icu/icu/icu4c/source/i18n/tridpars.cpp
@@ -50,7 +50,10 @@ static UInitOnce gSpecialInversesInitOnce = U_INITONCE_INITIALIZER;
 /**
  * The mutex controlling access to SPECIAL_INVERSES
  */
-static UMutex LOCK;
+static UMutex *LOCK() {
+    static UMutex m;
+    return &m;
+}
 
 TransliteratorIDParser::Specs::Specs(const UnicodeString& s, const UnicodeString& t,
                                      const UnicodeString& v, UBool sawS,
@@ -659,7 +662,7 @@ void TransliteratorIDParser::registerSpecialInverse(const UnicodeString& target,
         bidirectional = FALSE;
     }
 
-    Mutex lock(&LOCK);
+    Mutex lock(LOCK());
 
     UnicodeString *tempus = new UnicodeString(inverseTarget);  // Used for null pointer check before usage.
     if (tempus == NULL) {
@@ -863,9 +866,9 @@ TransliteratorIDParser::specsToSpecialInverse(const Specs& specs, UErrorCode &st
 
     UnicodeString* inverseTarget;
 
-    umtx_lock(&LOCK);
+    umtx_lock(LOCK());
     inverseTarget = (UnicodeString*) SPECIAL_INVERSES->get(specs.target);
-    umtx_unlock(&LOCK);
+    umtx_unlock(LOCK());
 
     if (inverseTarget != NULL) {
         // If the original ID contained "Any-" then make the
diff --git a/icu/icu/icu4c/source/i18n/tzfmt.cpp b/icu/icu/icu4c/source/i18n/tzfmt.cpp
index 22e5f5aa..b208ab38 100644
--- a/icu/icu/icu4c/source/i18n/tzfmt.cpp
+++ b/icu/icu/icu4c/source/i18n/tzfmt.cpp
@@ -147,7 +147,10 @@ static icu::UInitOnce gZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
 static TextTrieMap *gShortZoneIdTrie = NULL;
 static icu::UInitOnce gShortZoneIdTrieInitOnce = U_INITONCE_INITIALIZER;
 
-static UMutex gLock;
+static UMutex *gLock() {
+    static UMutex m;
+    return &m;
+}
 
 U_CDECL_BEGIN
 /**
@@ -1382,12 +1385,12 @@ TimeZoneFormat::getTimeZoneGenericNames(UErrorCode& status) const {
         return NULL;
     }
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     if (fTimeZoneGenericNames == NULL) {
         TimeZoneFormat *nonConstThis = const_cast<TimeZoneFormat *>(this);
         nonConstThis->fTimeZoneGenericNames = TimeZoneGenericNames::createInstance(fLocale, status);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     return fTimeZoneGenericNames;
 }
@@ -1398,7 +1401,7 @@ TimeZoneFormat::getTZDBTimeZoneNames(UErrorCode& status) const {
         return NULL;
     }
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     if (fTZDBTimeZoneNames == NULL) {
         TZDBTimeZoneNames *tzdbNames = new TZDBTimeZoneNames(fLocale);
         if (tzdbNames == NULL) {
@@ -1408,7 +1411,7 @@ TimeZoneFormat::getTZDBTimeZoneNames(UErrorCode& status) const {
             nonConstThis->fTZDBTimeZoneNames = tzdbNames;
         }
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     return fTZDBTimeZoneNames;
 }
diff --git a/icu/icu/icu4c/source/i18n/tzgnames.cpp b/icu/icu/icu4c/source/i18n/tzgnames.cpp
index 51f8c2f2..7e7722dc 100644
--- a/icu/icu/icu4c/source/i18n/tzgnames.cpp
+++ b/icu/icu/icu4c/source/i18n/tzgnames.cpp
@@ -269,7 +269,10 @@ GNameSearchHandler::getMatches(int32_t& maxMatchLen) {
     return results;
 }
 
-static UMutex gLock;
+static UMutex *gLock() {
+    static UMutex m;
+    return &m;
+}
 
 class TZGNCore : public UMemory {
 public:
@@ -485,11 +488,11 @@ TZGNCore::getGenericLocationName(const UnicodeString& tzCanonicalID, UnicodeStri
 
     const UChar *locname = NULL;
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         locname = nonConstThis->getGenericLocationName(tzCanonicalID);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (locname == NULL) {
         name.setToBogus();
@@ -740,11 +743,11 @@ TZGNCore::getPartialLocationName(const UnicodeString& tzCanonicalID,
 
     const UChar *uplname = NULL;
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         uplname = nonConstThis->getPartialLocationName(tzCanonicalID, mzID, isLong, mzDisplayName);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (uplname == NULL) {
         name.setToBogus();
@@ -1007,11 +1010,11 @@ TZGNCore::findLocal(const UnicodeString& text, int32_t start, uint32_t types, UE
 
     TZGNCore *nonConstThis = const_cast<TZGNCore *>(this);
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&handler, status);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (U_FAILURE(status)) {
         return NULL;
@@ -1038,7 +1041,7 @@ TZGNCore::findLocal(const UnicodeString& text, int32_t start, uint32_t types, UE
 
     // All names are not yet loaded into the local trie.
     // Load all available names into the trie. This could be very heavy.
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         if (!fGNamesTrieFullyLoaded) {
             StringEnumeration *tzIDs = TimeZone::createTimeZoneIDEnumeration(UCAL_ZONE_TYPE_CANONICAL, NULL, NULL, status);
@@ -1060,18 +1063,18 @@ TZGNCore::findLocal(const UnicodeString& text, int32_t start, uint32_t types, UE
             }
         }
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     if (U_FAILURE(status)) {
         return NULL;
     }
 
-    umtx_lock(&gLock);
+    umtx_lock(gLock());
     {
         // now try it again
         fGNamesTrie.search(text, start, (TextTrieMapSearchResultHandler *)&handler, status);
     }
-    umtx_unlock(&gLock);
+    umtx_unlock(gLock());
 
     results = handler.getMatches(maxLen);
     if (results != NULL && maxLen > 0) {
@@ -1112,7 +1115,10 @@ typedef struct TZGNCoreRef {
 } TZGNCoreRef;
 
 // TZGNCore object cache handling
-static UMutex gTZGNLock;
+static UMutex *gTZGNLock() {
+    static UMutex m;
+    return &m;
+}
 static UHashtable *gTZGNCoreCache = NULL;
 static UBool gTZGNCoreCacheInitialized = FALSE;
 
@@ -1178,13 +1184,13 @@ TimeZoneGenericNames::TimeZoneGenericNames()
 }
 
 TimeZoneGenericNames::~TimeZoneGenericNames() {
-    umtx_lock(&gTZGNLock);
+    umtx_lock(gTZGNLock());
     {
         U_ASSERT(fRef->refCount > 0);
         // Just decrement the reference count
         fRef->refCount--;
     }
-    umtx_unlock(&gTZGNLock);
+    umtx_unlock(gTZGNLock());
 }
 
 TimeZoneGenericNames*
@@ -1200,7 +1206,7 @@ TimeZoneGenericNames::createInstance(const Locale& locale, UErrorCode& status) {
 
     TZGNCoreRef *cacheEntry = NULL;
     {
-        Mutex lock(&gTZGNLock);
+        Mutex lock(gTZGNLock());
 
         if (!gTZGNCoreCacheInitialized) {
             // Create empty hashtable
@@ -1292,13 +1298,13 @@ TimeZoneGenericNames*
 TimeZoneGenericNames::clone() const {
     TimeZoneGenericNames* other = new TimeZoneGenericNames();
     if (other) {
-        umtx_lock(&gTZGNLock);
+        umtx_lock(gTZGNLock());
         {
             // Just increments the reference count
             fRef->refCount++;
             other->fRef = fRef;
         }
-        umtx_unlock(&gTZGNLock);
+        umtx_unlock(gTZGNLock());
     }
     return other;
 }
diff --git a/icu/icu/icu4c/source/i18n/tznames.cpp b/icu/icu/icu4c/source/i18n/tznames.cpp
index 50d7a665..35fb23d5 100644
--- a/icu/icu/icu4c/source/i18n/tznames.cpp
+++ b/icu/icu/icu4c/source/i18n/tznames.cpp
@@ -29,7 +29,10 @@
 U_NAMESPACE_BEGIN
 
 // TimeZoneNames object cache handling
-static UMutex gTimeZoneNamesLock;
+static UMutex *gTimeZoneNamesLock() {
+    static UMutex m;
+    return &m;
+}
 static UHashtable *gTimeZoneNamesCache = NULL;
 static UBool gTimeZoneNamesCacheInitialized = FALSE;
 
@@ -132,7 +135,7 @@ TimeZoneNamesDelegate::TimeZoneNamesDelegate()
 }
 
 TimeZoneNamesDelegate::TimeZoneNamesDelegate(const Locale& locale, UErrorCode& status) {
-    Mutex lock(&gTimeZoneNamesLock);
+    Mutex lock(gTimeZoneNamesLock());
     if (!gTimeZoneNamesCacheInitialized) {
         // Create empty hashtable if it is not already initialized.
         gTimeZoneNamesCache = uhash_open(uhash_hashChars, uhash_compareChars, NULL, &status);
@@ -208,7 +211,7 @@ TimeZoneNamesDelegate::TimeZoneNamesDelegate(const Locale& locale, UErrorCode& s
 }
 
 TimeZoneNamesDelegate::~TimeZoneNamesDelegate() {
-    umtx_lock(&gTimeZoneNamesLock);
+    umtx_lock(gTimeZoneNamesLock());
     {
         if (fTZnamesCacheEntry) {
             U_ASSERT(fTZnamesCacheEntry->refCount > 0);
@@ -216,7 +219,7 @@ TimeZoneNamesDelegate::~TimeZoneNamesDelegate() {
             fTZnamesCacheEntry->refCount--;
         }
     }
-    umtx_unlock(&gTimeZoneNamesLock);
+    umtx_unlock(gTimeZoneNamesLock());
 }
 
 UBool
@@ -237,13 +240,13 @@ TimeZoneNames*
 TimeZoneNamesDelegate::clone() const {
     TimeZoneNamesDelegate* other = new TimeZoneNamesDelegate();
     if (other != NULL) {
-        umtx_lock(&gTimeZoneNamesLock);
+        umtx_lock(gTimeZoneNamesLock());
         {
             // Just increment the reference count
             fTZnamesCacheEntry->refCount++;
             other->fTZnamesCacheEntry = fTZnamesCacheEntry;
         }
-        umtx_unlock(&gTimeZoneNamesLock);
+        umtx_unlock(gTimeZoneNamesLock());
     }
     return other;
 }
diff --git a/icu/icu/icu4c/source/i18n/tznames_impl.cpp b/icu/icu/icu4c/source/i18n/tznames_impl.cpp
index e9f9e7e9..908d8326 100644
--- a/icu/icu/icu4c/source/i18n/tznames_impl.cpp
+++ b/icu/icu/icu4c/source/i18n/tznames_impl.cpp
@@ -49,7 +49,10 @@ static const UChar NO_NAME[]            = { 0 };   // for empty no-fallback time
 static const char* TZDBNAMES_KEYS[]               = {"ss", "sd"};
 static const int32_t TZDBNAMES_KEYS_SIZE = UPRV_LENGTHOF(TZDBNAMES_KEYS);
 
-static UMutex gDataMutex;
+static UMutex *gDataMutex() {
+    static UMutex m;
+    return &m;
+}
 
 static UHashtable* gTZDBNamesMap = NULL;
 static icu::UInitOnce gTZDBNamesMapInitOnce = U_INITONCE_INITIALIZER;
@@ -1211,7 +1214,7 @@ TimeZoneNamesImpl::getMetaZoneDisplayName(const UnicodeString& mzID,
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         znames = nonConstThis->loadMetaZoneNames(mzID, status);
         if (U_FAILURE(status)) { return name; }
@@ -1237,7 +1240,7 @@ TimeZoneNamesImpl::getTimeZoneDisplayName(const UnicodeString& tzID, UTimeZoneNa
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         tznames = nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return name; }
@@ -1260,7 +1263,7 @@ TimeZoneNamesImpl::getExemplarLocationName(const UnicodeString& tzID, UnicodeStr
     TimeZoneNamesImpl *nonConstThis = const_cast<TimeZoneNamesImpl *>(this);
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         UErrorCode status = U_ZERO_ERROR;
         tznames = nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return name; }
@@ -1355,7 +1358,7 @@ TimeZoneNamesImpl::find(const UnicodeString& text, int32_t start, uint32_t types
     // Synchronize so that data is not loaded multiple times.
     // TODO: Consider more fine-grained synchronization.
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
 
         // First try of lookup.
         matches = doFind(handler, text, start, status);
@@ -1582,7 +1585,7 @@ void TimeZoneNamesImpl::loadAllDisplayNames(UErrorCode& status) {
     if (U_FAILURE(status)) return;
 
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         internalLoadAllDisplayNames(status);
     }
 }
@@ -1599,7 +1602,7 @@ void TimeZoneNamesImpl::getDisplayNames(const UnicodeString& tzID,
 
     // Load the time zone strings
     {
-        Mutex lock(&gDataMutex);
+        Mutex lock(gDataMutex());
         tznames = (void*) nonConstThis->loadTimeZoneNames(tzID, status);
         if (U_FAILURE(status)) { return; }
     }
@@ -1619,7 +1622,7 @@ void TimeZoneNamesImpl::getDisplayNames(const UnicodeString& tzID,
                 } else {
                     // Load the meta zone strings
                     // Mutex is scoped to the "else" statement
-                    Mutex lock(&gDataMutex);
+                    Mutex lock(gDataMutex());
                     mznames = (void*) nonConstThis->loadMetaZoneNames(mzID, status);
                     if (U_FAILURE(status)) { return; }
                     // Note: when the metazone doesn't exist, in Java, loadMetaZoneNames returns
diff --git a/icu/icu/icu4c/source/i18n/zonemeta.cpp b/icu/icu/icu4c/source/i18n/zonemeta.cpp
index 72c590f4..e605813c 100644
--- a/icu/icu/icu4c/source/i18n/zonemeta.cpp
+++ b/icu/icu/icu4c/source/i18n/zonemeta.cpp
@@ -30,7 +30,10 @@
 #include "olsontz.h"
 #include "uinvchar.h"
 
-static icu::UMutex gZoneMetaLock;
+static icu::UMutex *gZoneMetaLock() {
+    static icu::UMutex m;
+    return &m;
+}
 
 // CLDR Canonical ID mapping table
 static UHashtable *gCanonicalIDCache = NULL;
@@ -263,11 +266,11 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
     }
 
     // Check if it was already cached
-    umtx_lock(&gZoneMetaLock);
+    umtx_lock(gZoneMetaLock());
     {
         canonicalID = (const UChar *)uhash_get(gCanonicalIDCache, utzid);
     }
-    umtx_unlock(&gZoneMetaLock);
+    umtx_unlock(gZoneMetaLock());
 
     if (canonicalID != NULL) {
         return canonicalID;
@@ -348,7 +351,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
         U_ASSERT(canonicalID != NULL);  // canocanilD must be non-NULL here
 
         // Put the resolved canonical ID to the cache
-        umtx_lock(&gZoneMetaLock);
+        umtx_lock(gZoneMetaLock());
         {
             const UChar* idInCache = (const UChar *)uhash_get(gCanonicalIDCache, utzid);
             if (idInCache == NULL) {
@@ -368,7 +371,7 @@ ZoneMeta::getCanonicalCLDRID(const UnicodeString &tzid, UErrorCode& status) {
                 }
             }
         }
-        umtx_unlock(&gZoneMetaLock);
+        umtx_unlock(gZoneMetaLock());
     }
 
     return canonicalID;
@@ -446,14 +449,14 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
         // Check if it was already cached
         UBool cached = FALSE;
         UBool singleZone = FALSE;
-        umtx_lock(&gZoneMetaLock);
+        umtx_lock(gZoneMetaLock());
         {
             singleZone = cached = gSingleZoneCountries->contains((void*)region);
             if (!cached) {
                 cached = gMultiZonesCountries->contains((void*)region);
             }
         }
-        umtx_unlock(&gZoneMetaLock);
+        umtx_unlock(gZoneMetaLock());
 
         if (!cached) {
             // We need to go through all zones associated with the region.
@@ -472,7 +475,7 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
             delete ids;
 
             // Cache the result
-            umtx_lock(&gZoneMetaLock);
+            umtx_lock(gZoneMetaLock());
             {
                 UErrorCode ec = U_ZERO_ERROR;
                 if (singleZone) {
@@ -485,7 +488,7 @@ ZoneMeta::getCanonicalCountry(const UnicodeString &tzid, UnicodeString &country,
                     }
                 }
             }
-            umtx_unlock(&gZoneMetaLock);
+            umtx_unlock(gZoneMetaLock());
         }
 
         if (singleZone) {
@@ -572,11 +575,11 @@ ZoneMeta::getMetazoneMappings(const UnicodeString &tzid) {
     // get the mapping from cache
     const UVector *result = NULL;
 
-    umtx_lock(&gZoneMetaLock);
+    umtx_lock(gZoneMetaLock());
     {
         result = (UVector*) uhash_get(gOlsonToMeta, tzidUChars);
     }
-    umtx_unlock(&gZoneMetaLock);
+    umtx_unlock(gZoneMetaLock());
 
     if (result != NULL) {
         return result;
@@ -590,7 +593,7 @@ ZoneMeta::getMetazoneMappings(const UnicodeString &tzid) {
     }
 
     // put the new one into the cache
-    umtx_lock(&gZoneMetaLock);
+    umtx_lock(gZoneMetaLock());
     {
         // make sure it's already created
         result = (UVector*) uhash_get(gOlsonToMeta, tzidUChars);
@@ -618,7 +621,7 @@ ZoneMeta::getMetazoneMappings(const UnicodeString &tzid) {
             delete tmpResult;
         }
     }
-    umtx_unlock(&gZoneMetaLock);
+    umtx_unlock(gZoneMetaLock());
 
     return result;
 }
-- 
2.20.1.vfs.1.1.104.g2ab7360

